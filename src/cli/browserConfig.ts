import fs from 'node:fs/promises';
import path from 'node:path';
import type { BrowserSessionConfig } from '../sessionStore.js';
import type { ModelName, ThinkingTimeLevel } from '../oracle.js';
import { DEFAULT_MODEL_STRATEGY, DEFAULT_MODEL_TARGET, isTemporaryChatUrl, normalizeChatgptUrl, parseDuration } from '../browserMode.js';
import { normalizeBrowserModelStrategy } from '../browser/modelStrategy.js';
import type { BrowserModelStrategy } from '../browser/types.js';
import type { CookieParam } from '../browser/types.js';
import { defaultBrowserUrl, resolveBrowserProvider } from '../browser/provider.js';
import type { BrowserProvider } from '../browser/provider.js';
import { getOracleHomeDir } from '../oracleHome.js';

const DEFAULT_BROWSER_TIMEOUT_MS = 1_200_000;
const DEFAULT_BROWSER_INPUT_TIMEOUT_MS = 60_000;
const DEFAULT_CHROME_PROFILE = 'Default';

// Ordered array: most specific models first to ensure correct selection.
// The browser label is passed to the model picker which fuzzy-matches against ChatGPT's UI.
const BROWSER_MODEL_LABELS: [ModelName, string][] = [
  // Most specific first (e.g., "gpt-5.2-thinking" before "gpt-5.2")
  ['gpt-5.2-thinking', 'GPT-5.2 Thinking'],
  ['gpt-5.2-instant', 'GPT-5.2 Instant'],
  ['gpt-5.2-pro', 'GPT-5.2 Pro'],
  ['gpt-5.1-pro', 'GPT-5.2 Pro'],
  ['gpt-5-pro', 'GPT-5.2 Pro'],
  // Base models last (least specific)
  ['gpt-5.2', 'GPT-5.2'],       // Selects "Auto" in ChatGPT UI
  ['gpt-5.1', 'GPT-5.2'],       // Legacy alias â†’ Auto
  ['gemini-3-pro', 'Gemini 3 Pro'],
];

const GENSPARK_MODEL_LABELS: Array<[RegExp, string]> = [
  [/mixture[-\s]*of[-\s]*agents|moa/, 'Mixture-of-Agents'],
  [/gpt[-\s]*5(\.0)?[-\s]*pro/, 'GPT-5 Pro'],
  [/gpt[-\s]*5\.?1[-\s]*instant/, 'GPT-5.1 Instant'],
  [/gpt[-\s]*5\.?2[-\s]*pro/, 'GPT-5.2 Pro'],
  [/gpt[-\s]*5\.?2(?!.*pro)/, 'GPT-5.2'],
  [/o3[-\s]*pro/, 'o3-pro'],
  [/claude.*sonnet.*4\.5|sonnet.*4\.5/, 'Claude Sonnet 4.5'],
  [/claude.*opus.*4\.5|opus.*4\.5/, 'Claude Opus 4.5'],
  [/claude.*haiku.*4\.5|haiku.*4\.5/, 'Claude Haiku 4.5'],
  [/gemini.*2\.5.*pro/, 'Gemini 2.5 Pro'],
  [/gemini.*3.*flash.*preview/, 'Gemini 3 Flash Preview'],
  [/gemini.*3.*pro.*preview/, 'Gemini 3 Pro Preview'],
  [/grok\s*4\s*0709|grok4\s*0709|grok-4-0709|grok4-0709/, 'Grok4 0709'],
];

export interface BrowserFlagOptions {
  browserProvider?: BrowserProvider;
  browserChromeProfile?: string;
  browserChromePath?: string;
  browserCookiePath?: string;
  chatgptUrl?: string;
  browserUrl?: string;
  browserTimeout?: string;
  browserInputTimeout?: string;
  browserCookieWait?: string;
  browserNoCookieSync?: boolean;
  browserInlineCookiesFile?: string;
  browserCookieNames?: string;
  browserInlineCookies?: string;
  browserHeadless?: boolean;
  browserHideWindow?: boolean;
  browserKeepBrowser?: boolean;
  browserManualLogin?: boolean;
  browserManualLoginProfileDir?: string | null;
  /** Thinking time intensity: 'light', 'standard', 'extended', 'heavy' */
  browserThinkingTime?: ThinkingTimeLevel;
  browserModelLabel?: string;
  browserModelStrategy?: BrowserModelStrategy;
  browserAllowCookieErrors?: boolean;
  remoteChrome?: string;
  browserPort?: number;
  browserDebugPort?: number;
  model: ModelName;
  verbose?: boolean;
}

export function normalizeChatGptModelForBrowser(model: ModelName): ModelName {
  const normalized = model.toLowerCase() as ModelName;
  if (!normalized.startsWith('gpt-') || normalized.includes('codex')) {
    return model;
  }

  // Pro variants: always resolve to the latest Pro model in ChatGPT.
  if (normalized === 'gpt-5-pro' || normalized === 'gpt-5.1-pro' || normalized.endsWith('-pro')) {
    return 'gpt-5.2-pro';
  }

  // Explicit model variants: keep as-is (they have their own browser labels)
  if (normalized === 'gpt-5.2-thinking' || normalized === 'gpt-5.2-instant') {
    return normalized;
  }

  // Legacy aliases: map to base GPT-5.2 (Auto)
  if (normalized === 'gpt-5.1') {
    return 'gpt-5.2';
  }

  return model;
}

export async function buildBrowserConfig(options: BrowserFlagOptions): Promise<BrowserSessionConfig> {
  const desiredModelOverride = options.browserModelLabel?.trim();
  const normalizedOverride = desiredModelOverride?.toLowerCase() ?? '';
  const baseModel = options.model.toLowerCase();
  const isChatGptModel = baseModel.startsWith('gpt-') && !baseModel.includes('codex');
  const shouldUseOverride = !isChatGptModel && normalizedOverride.length > 0 && normalizedOverride !== baseModel;
  const urlHint = options.browserUrl ?? options.chatgptUrl;
  const provider = resolveBrowserProvider({
    provider: options.browserProvider,
    url: urlHint,
    chatgptUrl: options.chatgptUrl,
  });
  const rawUrl =
    provider === 'chatgpt'
      ? options.chatgptUrl ?? options.browserUrl
      : options.browserUrl ?? options.chatgptUrl;
  const modelStrategy =
    provider === 'chatgpt'
      ? (normalizeBrowserModelStrategy(options.browserModelStrategy) ?? DEFAULT_MODEL_STRATEGY)
      : normalizeBrowserModelStrategy(options.browserModelStrategy) ?? 'ignore';
  const cookieNames = parseCookieNames(options.browserCookieNames ?? process.env.ORACLE_BROWSER_COOKIE_NAMES);
  let inline = await resolveInlineCookies({
    inlineArg: options.browserInlineCookies,
    inlineFileArg: options.browserInlineCookiesFile,
    envPayload: process.env.ORACLE_BROWSER_COOKIES_JSON,
    envFile: process.env.ORACLE_BROWSER_COOKIES_FILE,
    cwd: process.cwd(),
  });
  if (inline?.source?.startsWith('home:') && options.browserNoCookieSync !== true) {
    inline = undefined;
  }

  let remoteChrome: { host: string; port: number } | undefined;
  if (options.remoteChrome) {
    remoteChrome = parseRemoteChromeTarget(options.remoteChrome);
  }
  const fallbackUrl = defaultBrowserUrl(provider);
  const url = rawUrl ? normalizeChatgptUrl(rawUrl, fallbackUrl) : undefined;

  const desiredModel =
    provider === 'chatgpt'
      ? isChatGptModel
        ? mapModelToBrowserLabel(options.model)
        : shouldUseOverride
          ? desiredModelOverride
          : mapModelToBrowserLabel(options.model)
      : desiredModelOverride?.trim() || null;

  if (
    provider === 'chatgpt' &&
    modelStrategy === 'select' &&
    url &&
    isTemporaryChatUrl(url) &&
    /\bpro\b/i.test(desiredModel ?? '')
  ) {
    throw new Error(
      'Temporary Chat mode does not expose Pro models in the ChatGPT model picker. ' +
        'Remove "temporary-chat=true" from --chatgpt-url (or omit --chatgpt-url), or use a non-Pro model (e.g. --model gpt-5.2).',
    );
  }

  return {
    provider,
    chromeProfile: options.browserChromeProfile ?? DEFAULT_CHROME_PROFILE,
    chromePath: options.browserChromePath ?? null,
    chromeCookiePath: options.browserCookiePath ?? null,
    url,
    debugPort: selectBrowserPort(options),
    timeoutMs: options.browserTimeout ? parseDuration(options.browserTimeout, DEFAULT_BROWSER_TIMEOUT_MS) : undefined,
    inputTimeoutMs: options.browserInputTimeout
      ? parseDuration(options.browserInputTimeout, DEFAULT_BROWSER_INPUT_TIMEOUT_MS)
      : undefined,
    cookieSyncWaitMs: options.browserCookieWait ? parseDuration(options.browserCookieWait, 0) : undefined,
    cookieSync: options.browserNoCookieSync ? false : undefined,
    cookieNames,
    inlineCookies: inline?.cookies,
    inlineCookiesSource: inline?.source ?? null,
    headless: undefined, // disable headless; Cloudflare blocks it
    keepBrowser: options.browserKeepBrowser ? true : undefined,
    manualLogin: options.browserManualLogin === undefined ? undefined : options.browserManualLogin,
    manualLoginProfileDir: options.browserManualLoginProfileDir ?? undefined,
    hideWindow: options.browserHideWindow ? true : undefined,
    desiredModel,
    modelStrategy,
    debug: options.verbose ? true : undefined,
    // Allow cookie failures by default so runs can continue without Chrome/Keychain secrets.
    allowCookieErrors: options.browserAllowCookieErrors ?? true,
    remoteChrome,
    thinkingTime: options.browserThinkingTime,
  };
}

function selectBrowserPort(options: BrowserFlagOptions): number | null {
  const candidate = options.browserPort ?? options.browserDebugPort;
  if (candidate === undefined || candidate === null) return null;
  if (!Number.isFinite(candidate) || candidate <= 0 || candidate > 65_535) {
    throw new Error(`Invalid browser port: ${candidate}. Expected a number between 1 and 65535.`);
  }
  return candidate;
}

export function mapModelToBrowserLabel(model: ModelName): string {
  const normalized = normalizeChatGptModelForBrowser(model);
  // Iterate ordered array to find first match (most specific first)
  for (const [key, label] of BROWSER_MODEL_LABELS) {
    if (key === normalized) {
      return label;
    }
  }
  return DEFAULT_MODEL_TARGET;
}

export function resolveBrowserModelLabel(input: string | undefined, model: ModelName): string {
  const trimmed = input?.trim?.() ?? '';
  if (!trimmed) {
    return mapModelToBrowserLabel(model);
  }
  const normalizedInput = trimmed.toLowerCase();
  if (normalizedInput === model.toLowerCase()) {
    return mapModelToBrowserLabel(model);
  }
  return trimmed;
}

export function resolveGensparkModelLabel(input: string | undefined): string | undefined {
  const trimmed = input?.trim?.() ?? '';
  if (!trimmed) return undefined;
  const normalized = trimmed.toLowerCase();
  if (normalized.includes('genspark')) return undefined;
  for (const [pattern, label] of GENSPARK_MODEL_LABELS) {
    if (pattern.test(normalized)) {
      return label;
    }
  }
  return trimmed;
}

function parseRemoteChromeTarget(raw: string): { host: string; port: number } {
  const target = raw.trim();
  if (!target) {
    throw new Error('Invalid remote-chrome value: expected host:port but received an empty string.');
  }

  const ipv6Match = target.match(/^\[(.+)]:(\d+)$/);
  let host: string | undefined;
  let portSegment: string | undefined;

  if (ipv6Match) {
    host = ipv6Match[1]?.trim();
    portSegment = ipv6Match[2]?.trim();
  } else {
    const lastColon = target.lastIndexOf(':');
    if (lastColon === -1) {
      throw new Error(
        `Invalid remote-chrome format: ${target}. Expected host:port (IPv6 must use [host]:port notation).`
      );
    }
    host = target.slice(0, lastColon).trim();
    portSegment = target.slice(lastColon + 1).trim();
    if (host.includes(':')) {
      throw new Error(
        `Invalid remote-chrome format: ${target}. Wrap IPv6 addresses in brackets, e.g. --remote-chrome "[2001:db8::1]:9222".`
      );
    }
  }

  if (!host) {
    throw new Error(
      `Invalid remote-chrome format: ${target}. Host portion is missing; expected host:port.`
    );
  }
  const port = Number.parseInt(portSegment ?? '', 10);
  if (!Number.isFinite(port) || port <= 0 || port > 65_535) {
    throw new Error(
      `Invalid remote-chrome port: "${portSegment ?? ''}". Expected a number between 1 and 65535.`
    );
  }
  return { host, port };
}

function parseCookieNames(raw?: string | null): string[] | undefined {
  if (!raw) return undefined;
  const names = raw
    .split(',')
    .map((entry) => entry.trim())
    .filter(Boolean);
  return names.length ? names : undefined;
}

async function resolveInlineCookies({
  inlineArg,
  inlineFileArg,
  envPayload,
  envFile,
  cwd,
}: {
  inlineArg?: string | null;
  inlineFileArg?: string | null;
  envPayload?: string | null;
  envFile?: string | null;
  cwd: string;
}): Promise<{ cookies: CookieParam[]; source: string } | undefined> {
  const tryLoad = async (source: string | undefined | null, allowPathResolution: boolean) => {
    if (!source) return undefined;
    const trimmed = source.trim();
    if (!trimmed) return undefined;
    if (allowPathResolution) {
      const resolved = path.isAbsolute(trimmed) ? trimmed : path.join(cwd, trimmed);
      try {
        const stat = await fs.stat(resolved);
        if (stat.isFile()) {
          const fileContent = await fs.readFile(resolved, 'utf8');
          const parsed = parseInlineCookiesPayload(fileContent);
          if (parsed) return parsed;
        }
      } catch {
        // not a file; treat as payload below
      }
    }
    return parseInlineCookiesPayload(trimmed);
  };

  const sources = [
    { value: inlineFileArg, allowPath: true, source: 'inline-file' },
    { value: inlineArg, allowPath: true, source: 'inline-arg' },
    { value: envFile, allowPath: true, source: 'env-file' },
    { value: envPayload, allowPath: false, source: 'env-payload' },
  ];

  for (const { value, allowPath, source } of sources) {
    const parsed = await tryLoad(value, allowPath);
    if (parsed) return { cookies: parsed, source };
  }

  // fallback: ~/.oracle/cookies.{json,base64}
  const oracleHome = getOracleHomeDir();
  const candidates = ['cookies.json', 'cookies.base64'];
  for (const file of candidates) {
    const fullPath = path.join(oracleHome, file);
    try {
      const stat = await fs.stat(fullPath);
      if (!stat.isFile()) continue;
      const content = await fs.readFile(fullPath, 'utf8');
      const parsed = parseInlineCookiesPayload(content);
      if (parsed) return { cookies: parsed, source: `home:${file}` };
    } catch {
      // ignore missing/invalid
    }
  }
  return undefined;
}

function parseInlineCookiesPayload(raw?: string | null): CookieParam[] | undefined {
  if (!raw) return undefined;
  const text = raw.trim();
  if (!text) return undefined;
  let jsonPayload = text;
  // Attempt base64 decode first; fall back to raw text on failure.
  try {
    const decoded = Buffer.from(text, 'base64').toString('utf8');
    if (decoded.trim().startsWith('[')) {
      jsonPayload = decoded;
    }
  } catch {
    // not base64; continue with raw text
  }
  try {
    const parsed = JSON.parse(jsonPayload) as unknown;
    if (Array.isArray(parsed)) {
      return parsed as CookieParam[];
    }
  } catch {
    // invalid json; skip silently to keep this hidden flag non-fatal
  }
  return undefined;
}
